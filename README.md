# 数据结构与算法

## 1. 数据结构

### 1.1 栈

### 1.2 队列

### 1.3 二叉树

### 1.4 二叉搜索树

### 1.5 图

## 2. 算法

### 2.1 递归

### 2.2 排序算法

#### 2.2.1 冒泡排序

时间复杂度：`O(N)`

空间复杂度：`O(1)`

内层循环每次两两比较，将最大值向右移到排序后的正确位置 `len(nums) - i`

由于内层循环每次将当前最大值放在最后，当外层循环到 `len(nums) - 1` 时，剩下最后一个元素已经为正确位置，所以该元素不需要额外排序

```go
func bubbleSort(nums []int) []int {
	for i := 0; i < len(nums) - 1; i++ {
		for j := 1; j < len(nums) - i; j++ {
			if nums[j - 1] > nums[j] {
				nums[j-1], nums[j] = nums[j], nums[j-1]
			}
		}
	}
	return nums
}
```



#### 2.2.2 桶排序

时间复杂度：`O(M+N)`

空间复杂度：`O(M)`，如果需要输出是切片的话，空间为`O(M+N)`

`M`是桶的大小

```go
// 输入在0~1000之间

// 桶排序需要知道一个数的取值范围，再根据取值范围生成相应数量的桶
// 遍历nums，每取出一个数在对应的桶中放一个旗子
// 最后遍历桶，将得到正确排序
func bucketSort(nums []int) {
	bucket := make([]int, 1001)
	for _, v := range nums {
		bucket[v]++
	}
	for i := range bucket {
		for j := 0; j < bucket[i]; j++ {
			fmt.Printf("%d ", i)
		}
	}
}
```



#### 2.2.3 插入排序

时间复杂度：

空间复杂度：

```go
// 将排序数组a想象为牌堆，默认抽第一张牌（下标为0）放入手牌（从0 ~ j均为手牌），手牌是已排序的
// 从 j = 1 开始摸牌，每抽到一张牌（记为 key = a[j]），跟手牌比较寻找插入位置
// 若 key 比当前比较的手牌 a[i] 大，则将手牌往后挪一位
// 找到插入位置后，key放置到空位 a[i + 1]

// 升序排序
func InsertionSort_Up(a []int) {
	for j := 1; j < len(a); j++ {
		i := j - 1
		key := a[j]
		for i >= 0 && a[i] > key {
			a[i + 1] = a[i]
			i--
		}
		a[i + 1] = key
	}
}
// 降序排序
func InsertionSort_Down(a []int) {
	for j := 1; j < len(a); j++ {
		i := j - 1
		key := a[j]
		for i >= 0 && a[i] < key {
			a[i + 1] = a[i]
			i--
		}
		a[i + 1] = key
	}
}
```



#### 2.2.4 归并排序

#### 2.2.5 快速排序

时间复杂度：

空间复杂度：

```go
func quickSort(arr []int, left, right int) {
	var i, j, temp int
	if left > right { return }

	temp = arr[left] // temp就是基准数
	i, j = left, right
	for i != j {
		// 顺序很重要，先从右往左找。找到比基准数小的数
		for ; arr[j] >= temp && i < j; j-- {}
		// 从左往右找，找到比基准数大的数
		for ; arr[i] <= temp && i < j; i++ {}
		if i < j { // 哨兵i和哨兵j没有相遇时
			arr[i], arr[j] = arr[j], arr[i] // 交换位置
		}
	}
	// 基准数归位
	arr[left] = arr[i]
	arr[i] = temp

	quickSort(arr, left, i-1) // 继续处理左边的，这是一个递归的过程
	quickSort(arr, i+1, right) // 继续处理右边的，这是一个递归的过程
}

```



### 2.3 二分查找

##### 2.3.1 简介

[引用]: https://www.cxyxiaowu.com/500.html	"一网打尽！二分查找解题模版与题型全面解析"



### 2.4 贪心思想

##### 2.4.1 简介

[引用]: https://www.cxyxiaowu.com/852.html	"五分钟了解一下什么是「贪心算法 」"



### 2.5 动态规划

#### 2.5.1 简介

[引用]: https://www.cxyxiaowu.com/6781.html	"有了四步解题法模板，再也不害怕动态规划！"

用一句话解释动态规划就是**“记住你之前做过的事”**，如果更准确些，其实是，**“记住你之前得到的答案”**

我举个大家工作中经常遇到的例子。

在软件开发中，大家经常会遇到一些系统配置的问题，配置不对，系统就会报错，这个时候一般都会去 Google 或者是查阅相关的文档，花了一定的时间将配置修改好。

过了一段时间，去到另一个系统，遇到类似的问题，这个时候已经记不清之前修改过的配置文件长什么样，这个时候有两种方案，一种方案还是去 Google 或者查阅文档，另一种方案是借鉴之前修改过的配置，第一种做法其实是万金油，因为你遇到的任何问题其实都可以去 Google，去查阅相关文件找答案，但是这会花费一定的时间，相比之下，第二种方案肯定会更加地节约时间，但是这个方案是有条件的，条件如下：

- 之前的问题和当前的问题有着关联性，换句话说，之前问题得到的答案可以帮助解决当前问题
- 需要记录之前问题的答案

当然在这个例子中，可以看到的是，上面这两个条件均满足，大可去到之前配置过的文件中，将配置拷贝过来，然后做些细微的调整即可解决当前问题，节约了大量的时间。

不知道你是否从这些描述中发现，对于一个动态规划问题，我们只需要从两个方面考虑，那就是 **找出问题之间的联系**，以及 **记录答案**，这里的难点其实是找出问题之间的联系，记录答案只是顺带的事情，利用一些简单的数据结构就可以做到。

#### 2.5.2 动态规划解题框架

一般解决动态规划问题，分为四个步骤，分别是

- 问题拆解，找到问题之间的具体联系
- 状态定义
- 递推方程推导
- 实现



这里面的重点其实是前两个，如果前两个步骤顺利完成，后面的递推方程推导和代码实现会变得非常简单。

这里还是拿 Quora 上面的例子来讲解，“1+1+1+1+1+1+1+1” 得出答案是 8，那么如何快速计算 “1+ 1+1+1+1+1+1+1+1”，我们首先可以对这个大的问题进行拆解，这里我说的大问题是 9 个 1 相加，这个问题可以拆解成 1 + “8 个 1 相加的答案”，8 个 1 相加继续拆，可以拆解成 1 + “7 个 1 相加的答案”，… 1 + “0 个 1 相加的答案”，到这里，**第一个步骤** 已经完成。

**状态定义** 其实是需要思考在解决一个问题的时候我们做了什么事情，然后得出了什么样的答案，对于这个问题，当前问题的答案就是当前的状态，基于上面的问题拆解，你可以发现两个相邻的问题的联系其实是 `后一个问题的答案 = 前一个问题的答案 + 1`，这里，状态的每次变化就是 +1。

定义好了状态，递推方程就变得非常简单，就是 `dp[i] = dp[i - 1] + 1`，这里的 `dp[i]` 记录的是当前问题的答案，也就是当前的状态，`dp[i - 1]` 记录的是之前相邻的问题的答案，也就是之前的状态，它们之间通过 +1 来实现状态的变更。

最后一步就是实现了，有了状态表示和递推方程，实现这一步上需要重点考虑的其实是初始化，就是用什么样的数据结构，根据问题的要求需要做那些初始值的设定。

```java
public int dpExample(int n) {
    int[] dp = new int[n + 1];  // 多开一位用来存放 0 个 1 相加的结果

    dp[0] = 0;      // 0 个 1 相加等于 0

    for (int i = 1; i <= n; ++i) {
        dp[i] = dp[i - 1] + 1;
    }

    return dp[n];
}
```

你可以看到，动态规划这四个步骤其实是相互递进的，状态的定义离不开问题的拆解，递推方程的推导离不开状态的定义，最后的实现代码的核心其实就是递推方程，这中间如果有一个步骤卡壳了则会导致问题无法解决，当问题的复杂程度增加的时候，这里面的思维复杂程度会上升。

#### 2.5.3 题目实战

##### 2.5.3.1 爬楼梯

###### 题目描述

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 *n* 是一个正整数。

**示例**1：

```
输入：2
输出：2
解释： 有两种方法可以爬到楼顶。

1. 1 阶 + 1 阶
2. 2 阶
```

**示例**2：

```
输入：3
输出：3
解释： 有三种方法可以爬到楼顶。

1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

###### 题目解析

爬楼梯，可以爬一步也可以爬两步，问有多少种不同的方式到达终点，我们按照上面提到的四个步骤进行分析：

- **问题拆解**：

  我们到达第 n 个楼梯可以从第 n – 1 个楼梯和第 n – 2 个楼梯到达，因此第 n 个问题可以拆解成第 n – 1 个问题和第 n – 2 个问题，第 n – 1 个问题和第 n – 2 个问题又可以继续往下拆，直到第 0 个问题，也就是第 0 个楼梯 (起点)

- **状态定义**

  “问题拆解” 中已经提到了，第 n 个楼梯会和第 n – 1 和第 n – 2 个楼梯有关联，那么具体的联系是什么呢？你可以这样思考，第 n – 1 个问题里面的答案其实是从起点到达第 n – 1 个楼梯的路径总数，n – 2 同理，从第 n – 1 个楼梯可以到达第 n 个楼梯，从第 n – 2 也可以，并且路径没有重复，因此我们可以把第 i 个状态定义为 “**从起点到达第 i 个楼梯的路径总数**”，状态之间的联系其实是相加的关系。

- **递推方程**

  “状态定义” 中我们已经定义好了状态，也知道第 i 个状态可以由第 i – 1 个状态和第 i – 2 个状态通过相加得到，因此递推方程就出来了 `dp[i] = dp[i - 1] + dp[i - 2]`

- **实现**

  你其实可以从递推方程看到，我们需要有一个初始值来方便我们计算，起始位置不需要移动 `dp[0] = 0`，第 1 层楼梯只能从起始位置到达，因此 `dp[1] = 1`，第 2 层楼梯可以从起始位置和第 1 层楼梯到达，因此 `dp[2] = 2`，有了这些初始值，后面就可以通过这几个初始值进行递推得到。

###### 参考代码

**Java**

```java
public int climbStairs(int n) {
    if (n == 1) {
        return 1;
    }

    int[] dp = new int[n + 1];  // 多开一位，考虑起始位置

    dp[0] = 0; dp[1] = 1; dp[2] = 2;
    for (int i = 3; i <= n; ++i) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    return dp[n];
}
```

**Go**

```go
func climbStairs(n int) int {
    // 状态定义：对于爬n个台阶，最后一次爬1个台阶的爬法为f(n-1)，最后一次爬2个台阶的爬法为f(n-2)
    // 递推公式：
    // f(n) = 1 (n <= 1时)
    // f(n) = f(n-1) + f(n-2) (n >= 2)
    if n <= 1 {
        return 1
    }
    dp := make([]int, n+1)
    dp[0], dp[1] = 1, 1
    for i := 2; i <= n; i++ {
        dp[i] = dp[i-1] + dp[i-2]
    }

    return dp[n]
}
```



##### 2.5.3.2 三角形最小路径和

###### 题目描述

给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

例如，给定三角形：

```
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
```

自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。

**说明：**

如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。

###### 题目解析

给定一个三角形数组，需要求出从上到下的最小路径和，也和之前一样，按照四个步骤来分析：

- 问题拆解：

  这里的总问题是求出最小的路径和，路径是这里的分析重点，路径是由一个个元素组成的，和之前爬楼梯那道题目类似，`[i][j]` 位置的元素，经过这个元素的路径肯定也会经过 `[i - 1][j]` 或者 `[i - 1][j - 1]`，因此经过一个元素的路径和可以通过这个元素上面的一个或者两个元素的路径和得到。

- 状态定义

  状态的定义一般会和问题需要求解的答案联系在一起，这里其实有两种方式，一种是考虑路径从上到下，另外一种是考虑路径从下到上，因为元素的值是不变的，所以路径的方向不同也不会影响最后求得的路径和，如果是从上到下，你会发现，在考虑下面元素的时候，起始元素的路径只会从`[i - 1][j]` 获得，每行当中的最后一个元素的路径只会从 `[i - 1][j - 1]` 获得，中间二者都可，这样不太好实现，因此这里考虑从下到上的方式，状态的定义就变成了 “**最后一行元素到当前元素的最小路径和**”，对于 `[0][0]` 这个元素来说，最后状态表示的就是我们的最终答案。

- 递推方程

  “状态定义” 中我们已经定义好了状态，递推方程就出来了

  ```
  dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle[i][j]
  ```

- 实现

  这里初始化时，我们需要将最后一行的元素填入状态数组中，然后就是按照前面分析的策略，从下到上计算即可

###### 参考代码

**Java**

```java
public int minimumTotal(List<List<Integer>> triangle) {
    int n = triangle.size();

    int[][] dp = new int[n][n];

    List<Integer> lastRow = triangle.get(n - 1);

    for (int i = 0; i < n; ++i) {
        dp[n - 1][i] = lastRow.get(i);
    }

    for (int i = n - 2; i >= 0; --i) {
        List<Integer> row = triangle.get(i);
        for (int j = 0; j < i + 1; ++j) {
            dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + row.get(j);
        }
    }

    return dp[0][0];
}
```

**Go**

```go
func minimumTotal(triangle [][]int) int {
    // 状态定义：某结点[i][j]的最小路径和为左右结点[i+1][j] 或 [i+1][j+1] 的最小路径和 加上本结点值
    // 最终结点[0][0]的值即为所求结果
    // 递推公式：
    // f(i, j) = triangle[i][j] (i == len(triangle))
    // f(i, j) = triangle[i][j] + min(f(i+1, j), f(i+1, j+1))
    for i := len(triangle) - 2; i >= 0; i-- {
        for j := 0; j < i+1; j++ {
            min := int(math.Min(float64(triangle[i+1][j]), float64(triangle[i+1][j+1])))
            triangle[i][j] = triangle[i][j] + min
        }
    }

    return triangle[0][0]
}
```



##### 2.5.3.3 最大子序和

###### 题目描述

给定一个整数数组 *nums* ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例:**

```
输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

**进阶:**

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。

###### 题目解析

求最大子数组和，非常经典的一道题目，这道题目有很多种不同的做法，而且很多算法思想都可以在这道题目上面体现出来，比如动态规划、贪心、分治，还有一些技巧性的东西，比如前缀和数组，这里还是使用动态规划的思想来解题，套路还是之前的四步骤：

- 问题拆解：

  问题的核心是子数组，子数组可以看作是一段区间，因此可以由起始点和终止点确定一个子数组，两个点中，我们先确定一个点，然后去找另一个点，比如说，如果我们确定一个子数组的截止元素在 i 这个位置，这个时候我们需要思考的问题是 “**以 i 结尾的所有子数组中，和最大的是多少？**”，然后我们去试着拆解，这里其实只有两种情况：

    i 这个位置的元素自成一个子数组;

    i 位置的元素的值 + **以 i – 1 结尾的所有子数组中的子数组和最大的值**

  你可以看到，我们把第 i 个问题拆成了第 i – 1 个问题，之间的联系也变得清晰

- 状态定义

  通过上面的分析，其实状态已经有了，`dp[i]` 就是 “**以 i 结尾的所有子数组的最大值**”

- 递推方程

  拆解问题的时候也提到了，有两种情况，即当前元素自成一个子数组，另外可以考虑前一个状态的答案，于是就有了

  ```
  dp[i] = Math.max(dp[i - 1] + array[i], array[i])
  ```

  化简一下就成了：

  ```
  dp[i] = Math.max(dp[i - 1], 0) + array[i]
  ```

- 实现

  题目要求子数组不能为空，因此一开始需要初始化，也就是 `dp[0] = array[0]`，保证最后答案的可靠性，另外我们需要用一个变量记录最后的答案，因为子数组有可能以数组中任意一个元素结尾

###### 参考代码

**Java**

```java
public int maxSubArray(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }

    int n = nums.length;

    int[] dp = new int[n];

    dp[0] = nums[0];

    int result = dp[0];

    for (int i = 1; i < n; ++i) {
        dp[i] = Math.max(dp[i - 1], 0) + nums[i];
        result = Math.max(result, dp[i]);
    }

    return result;
}
```

**Go**

```go
func maxSubArray(nums []int) int {
    // 状态定义：以i结尾的所有子数组的最大和是dp[i]
    // 注意：dp[len(nums)-1]并非答案，因为最大连续子数组不一定是以下标len(nums)-1为结尾
    // 递推方程：dp[i] = max(dp[i-1] + array[i], array[i])
    if len(nums) == 0 {
        return 0
    }
    dp := make([]int, len(nums))
    dp[0] = nums[0]
    // 注意：result初始值并不是0
    var result = dp[0]
    for i := 1; i < len(nums); i++ {
        max := int(math.Max(float64(dp[i-1]), 0))
        dp[i] = max + nums[i]
        result = int(math.Max(float64(dp[i]), float64(result)))
    }

    return result
}
```



### 2.6 滑动窗口

#### 2.6.1 简介

[引用]: https://www.cxyxiaowu.com/672.html	"面试官，你再问我滑动窗口问题试试？我有解题模板，不怕！"

滑动窗口这类问题一般需要用到 **双指针** 来进行求解，另外一类比较特殊则是需要用到特定的数据结构，像是 sorted_map。

后者有特定的题型，后面会列出来，但是，对于前者，题形变化非常的大，一般都是基于字符串和数组的，所以我们重点总结这种基于双指针的滑动窗口问题。

题目问法大致有这几种：

- 给两个字符串，一长一短，问其中短的是否在长的中满足一定的条件存在，例如：
- 求长的的最短子串，该子串必须涵盖短的的所有字符
- 短的的 anagram 在长的中出现的所有位置
- …
- 给一个字符串或者数组，问这个字符串的子串或者子数组是否满足一定的条件，例如：
- 含有少于 k 个不同字符的最长子串
- 所有字符都只出现一次的最长子串
- …

除此之外，还有一些其他的问法，但是不变的是，这类题目脱离不开主串（主数组）和子串（子数组）的关系，要求的时间复杂度往往是 O(n) ，空间复杂度往往是常数级的。

之所以是滑动窗口，是因为，遍历的时候，两个指针一前一后夹着的子串（子数组）类似一个窗口，这个窗口大小和范围会随着前后指针的移动发生变化。

![面试官，你再问我滑动窗口问题试试？我有解题模板，不怕！](http://www.cxyxiaowu.com/wp-content/uploads/2019/10/1571057536-4a4dd87048cbf50.jpg)双指针确定一个窗口

#### 2.6.2 解题思路及答题模板

根据前面的描述，滑动窗口就是这类题目的重点，换句话说，**窗口的移动** 就是重点！

我们要控制前后指针的移动来控制窗口，这样的移动是有条件的，也就是要想清楚在什么情况下移动，在什么情况下保持不变。

我的思路是保证右指针每次往前移动一格，每次移动都会有新的一个元素进入窗口，这时条件可能就会发生改变，然后根据当前条件来决定左指针是否移动，以及移动多少格。

我写来一个模版在这里，可以参考：

```java
//authour:P.yh
//Editor:程序员小吴
public int slidingWindowTemplate(String[] a, ...) {
    // 输入参数有效性判断
    if (...) {
        ...
    }

    // 申请一个散列，用于记录窗口中具体元素的个数情况
    // 这里用数组的形式呈现，也可以考虑其他数据结构
    int[] hash = new int[...];

    // 预处理(可省), 一般情况是改变 hash
    ...

    // l 表示左指针
    // count 记录当前的条件，具体根据题目要求来定义
    // result 用来存放结果
    int l = 0, count = ..., result = ...;
    for (int r = 0; r < A.length; ++r) {
        // 更新新元素在散列中的数量
        hash[A[r]]--;

        // 根据窗口的变更结果来改变条件值
        if (hash[A[r]] == ...) {
            count++;
        }

        // 如果当前条件不满足，移动左指针直至条件满足为止
        while (count > K || ...) {
            ...
            if (...) {
                count--;
            }
            hash[A[l]]++;
            l++;
        }

        // 更新结果
        results = ...
    }

    return results;
}
```

这里面的 “移动左指针直至条件满足” 部分，需要具体题目具体分析，其他部分的变化不大。

#### 2.6.3 具体题目分析与代码

##### 2.6.3.1 找到字符串中所有字母异位词

题目来源于 LeetCode 上第 438 号问题：找到字符串中所有字母异位词。题目难度为 Easy，目前通过率为 43.6% 。

###### 题目描述

给定一个字符串 **s** 和一个非空字符串 **p**，找到 **s** 中所有是 **p** 的字母异位词的子串，返回这些子串的起始索引。

字符串只包含小写英文字母，并且字符串 **s** 和 **p** 的长度都不超过 **20100** 。

###### 题目解析

别看这是一道 easy 难度的题目，如果限定你在 O(n) 时间复杂度内实现呢？

按照模版会很简单！

首先窗口是固定的，窗口长度就是输入参数中第二个字符串的长度，也就是说，右指针移动到某个位置后，左指针必须跟着一同移动，且每次移动都是一格，模版中 count 用来记录窗口内满足条件的元素，直到 count 和窗口长度相等即可更新答案。

###### 代码实现

```java
// 使用上面的模板进行解题，so easy ！
public List<Integer> findAnagrams(String s, String p) {
    // 输入参数有效性判断
    if (s.length() < p.length()) {
        return new ArrayList<Integer>();
    }

    // 申请一个散列，用于记录窗口中具体元素的个数情况
    // 这里用数组的形式呈现，也可以考虑其他数据结构
    char[] sArr = s.toCharArray();
    char[] pArr = p.toCharArray();

    int[] hash = new int[26];

    for (int i = 0; i < pArr.length; ++i) {
        hash[pArr[i] - 'a']++;
    }

    // l 表示左指针
    // count 记录当前的条件，具体根据题目要求来定义
    // result 用来存放结果
    List<Integer> results = new ArrayList<>();
    int l = 0, count = 0, pLength = p.length();

    for (int r = 0; r < sArr.length; ++r) {
        // 更新新元素在散列中的数量
        hash[sArr[r] - 'a']--;

        // 根据窗口的变更结果来改变条件值
        if (hash[sArr[r] - 'a'] >= 0) {
            count++;
        }

        // 如果当前条件不满足，移动左指针直至条件满足为止
        if (r > pLength - 1) {
            hash[sArr[l] - 'a']++;

            if (hash[sArr[l] - 'a'] > 0) {
                count--;
            }

            l++;
        }

        // 更新结果
        if (count == pLength) {
            results.add(l);
        }
    }

    return results;
}
```

##### 2.6.3.2 最小覆盖子串

题目来源于 LeetCode 上第 76 号问题：最小覆盖子串。题目难度为 Hard，目前通过率为 35.8% 。

###### 题目描述

给你一个字符串 **S**、一个字符串 **T**，请在字符串 **S** 里面找出：包含 **T** 所有字母的最小子串。

**示例：**

```java
输入: S = "ADOBECODEBANC", T = "ABC"输出: "BANC"
```

###### 题目解析

同样是两个字符串之间的关系问题，因为题目求的最小子串，也就是窗口的最小长度，说明这里的窗口大小是可变的，这里移动左指针的条件变成，只要左指针指向不需要的字符，就进行移动。

依旧使用上面的模板解题！

###### 代码实现 

```java
// 使用上面的模板进行解题，受篇幅限制下面的代码就不添加注释了
public String minWindow(String s, String t) {
    if (s.length() < t.length()) {
        return "";
    }

    char[] sArr = s.toCharArray();
    char[] tArr = t.toCharArray();

    int[] hash = new int[256];

    for (int i = 0; i < tArr.length; ++i) {
        hash[tArr[i]]++;
    }

    int l = 0, count = tArr.length, max = s.length() + 1;
    String result = "";
    for (int r = 0; r < sArr.length; ++r) {
        hash[sArr[r]]--;

        if (hash[sArr[r]] >= 0) {
            count--;
        }

        while (l < r && hash[sArr[l]] < 0) {
            hash[sArr[l]]++;
            l++;
        }

        if (count == 0 && max > r - l + 1) {
            max = r - l + 1;
            result = s.substring(l, r + 1);
        }
    }

    return result;
}
```

#####  2.6.3.3 无重复字符的最长子串 

题目来源于 LeetCode 上第 3 号问题：无重复字符的最长子串。题目难度为 Medium，目前通过率为 29.0% 。

###### 题目描述

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

```java
输入: "abcabcbb"输出: 3 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

###### 题目解析

输入只有一个字符串，要求子串里面不能够有重复的元素，这里 count 都不需要定义，直接判断哈希散列里面的元素是不是在窗口内即可，是的话得移动左指针去重。

具体操作如下：

建立一个 256 位大小的整型数组 freg ，用来建立字符和其出现位置之间的映射。

维护一个滑动窗口，窗口内的都是没有重复的字符，去尽可能的扩大窗口的大小，窗口不停的向右滑动。

- （1）如果当前遍历到的字符从未出现过，那么直接扩大右边界；
- （2）如果当前遍历到的字符出现过，则缩小窗口（左边索引向右移动），然后继续观察当前遍历到的字符；
- （3）重复（1）（2），直到左边索引无法再移动；
- （4）维护一个结果 res，每次用出现过的窗口大小来更新结果 res，最后返回 res 获取结果。

###### 动画描述

![面试官，你再问我滑动窗口问题试试？我有解题模板，不怕！](http://www.cxyxiaowu.com/wp-content/uploads/2019/10/1571057537-818020d836023ea.gif)

###### 代码实现

```java
public int lengthOfLongestSubstring(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }

    char[] sArr = s.toCharArray();
    int[] hash = new int[256];

    int l = 0, result = 1;
    for (int r = 0; r < sArr.length; ++r) {
        hash[sArr[r]]++;

        while (hash[sArr[r]] != 1) {
            hash[sArr[l]]--;
            l++;
        }

        result = Math.max(result, r - l + 1);
    }

    return result;
}
```

##### 2.6.3.4 字符串的排列

题目来源于 LeetCode 上第 567 号问题：字符串的排列。题目难度为 Medium，目前通过率为 31.8% 。

###### 题目描述

给定两个字符串 **s1** 和 **s2**，写一个函数来判断 **s2** 是否包含 **s1** 的排列。

换句话说，第一个字符串的排列之一是第二个字符串的子串。

**示例1:**

```
输入: s1 = "ab" s2 = "eidbaooo"输出: True解释: s2 包含 s1 的排列之一 ("ba").
```

**示例2:**

```
输入: s1= "ab" s2 = "eidboaoo"输出: False
```

###### 题目解析

和 438 那题很类似，但是这里不需要记录答案了，有就直接返回 true。

###### 代码实现

```java
public boolean checkInclusion(String s1, String s2) {
    if (s1.length() > s2.length()) {
        return false;
    }

    char[] s1Arr = s1.toCharArray();
    char[] s2Arr = s2.toCharArray();

    int[] hash = new int[26];

    for (int i = 0; i < s1Arr.length; ++i) {
        hash[s1Arr[i] - 'a']++;
    }

    int l = 0, count = 0;
    for (int r = 0; r < s2Arr.length; ++r) {
        hash[s2Arr[r] - 'a']--;

        if (hash[s2Arr[r] - 'a'] >= 0) {
            count++;
        }

        if (r >= s1Arr.length) {
            hash[s2Arr[l] - 'a']++;

            if (hash[s2Arr[l] - 'a'] >= 1) {
                count--;
            }

            l++;
        }

        if (count == s1Arr.length) {
            return true;
        }
    }

    return false;
}
```

##### 2.6.3.5 K 个不同整数的子数组

题目来源于 LeetCode 上第 992 号问题：字符串的排列。题目难度为 Hard，目前通过率为 26.4% 。

###### 题目描述

给定一个正整数数组 **A**，如果 **A** 的某个子数组中不同整数的个数恰好为 **K**，则称 **A** 的这个连续、不一定独立的子数组为好子数组。

（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。）

返回 **A **中好子数组的数目。

**示例 1：**

```
输出：A = [1,2,1,2,3], K = 2输入：7解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].
```

**示例 2：**

```
输入：A = [1,2,1,3,4], K = 3输出：3解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].
```

###### 题目解析

看完了字符串类型的题目，这次来看看数组类型的。

题目中的 subarray 已经明确了这个题可以考虑用滑动窗口，这题比较 trick 的一个地方在于，这里不是求最小值最大值，而是要你计数。

但是如果每次仅仅加 1 的话又不太对，例如 `A = [1,2,1,2,3], K = 2` 这个例子，假如右指针移到 index 为 3 的位置，如果按之前的思路左指针根据 count 来移动，当前窗口是 `[1,2,1,2]`，但是怎么把 `[2,1]` 给考虑进去呢？

可以从数组和子数组的关系来思考！

假如 `[1,2,1,2]` 是符合条件的数组，如果要计数的话，`[1,2,1,2]` 要求的结果是否和 `[1,2,1]` 的结果存在联系？这两个数组的区别在于多了一个新进来的元素，之前子数组计数没考虑到这个元素，假如把这个元素放到之前符合条件的子数组中组成的新数组也是符合条件的，我们看看这个例子中所有满足条件的窗口以及对应的满足条件的子数组情况：

```java
[1,2,1,2,3]  // 窗口满足条件
 l r         // 满足条件的子数组 [1,2]

[1,2,1,2,3]  // 窗口满足条件
 l   r       // 满足条件的子数组 [1,2],[2,1],[1,2,1]

[1,2,1,2,3]  // 窗口满足条件
 l     r     // 满足条件的子数组 [1,2],[2,1],[1,2,1],[1,2],[2,1,2],[1,2,1,2]

[1,2,1,2,3]  // 窗口不满足条件，移动左指针至满足条件
 l       r   

[1,2,1,2,3]  // 窗口满足条件
       l r   // 满足条件的子数组 [1,2],[2,1],[1,2,1],[1,2],[2,1,2],[1,2,1,2],[2,3]
```

你可以看到对于一段连续的数组，新的元素进来，窗口增加 1，每次的增量都会在前一次增量的基础上加 1。

当新的元素进来打破当前条件会使这个增量从新回到 1，这样我们左指针移动条件就是只要是移动不会改变条件，就移动，不然就停止。

###### 代码实现

```java
public int subarraysWithKDistinct(int[] A, int K) {
    if (A == null || A.length < K) {
        return 0;
    }

    int[] hash = new int[A.length + 1];

    int l = 0, results = 0, count = 0, result = 1;
    for (int r = 0; r < A.length; ++r) {
        hash[A[r]]++;

        if (hash[A[r]] == 1) {
            count++;
        }

        while (hash[A[l]] > 1 || count > K) {
            if (count > K) {
                result = 1;
                count--;
            } else {
                result++;
            }
            hash[A[l]]--;
            l++;
        }

        if (count == K) {
            results += result;
        }
    }

    return results;
}
```

##### 2.3.6.6 替换后的最长重复字符

题目来源于 LeetCode 上第 424 号问题：替换后的最长重复字符。题目难度为 Medium，目前通过率为 37.3% 。

###### 题目描述

给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 *k* 次。在执行上述操作后，找到包含重复字母的最长子串的长度。

###### 题目解析

这道题想 accept 的话不难，但是问题在于怎么知道当前窗口中数量最多的字符的数量，因为需要替换的字符就是当前窗口的大小减去窗口中数量最多的字符的数量。

最简单的方法就是把 **哈希散列** 遍历一边找到最大的字符数量，但是仔细想想如果我们每次新进元素都更新这个最大数量，且只更新一次，我们保存的是当前遍历过的全局的最大值，它肯定是比实际的最大值大的，我们左指针移动的条件是 `r - l + 1 - maxCount > k`，保存的结果是 `result = Math.max(r - l + 1, result);` 这里 maxCount 比实际偏大的话，虽然导致左指针不能移动，但是不会记录当前的结果，所以最后的答案并不会受影响。

###### 代码实现

```java
public int characterReplacement(String s, int k) {
    if (s == null || s.length() == 0) {
        return 0;
    }

    char[] sArr = s.toCharArray();

    int[] hash = new int[26];

    int l = 0, maxCount = 0, result = 0;
    for (int r = 0; r < sArr.length; ++r) {
        hash[sArr[r] - 'A']++;

        maxCount = Math.max(maxCount, hash[sArr[r] - 'A']);

        while (r - l + 1 - maxCount > k) {
            hash[sArr[l] - 'A']--;
            l++;
        }

        result = Math.max(r - l + 1, result);
    }

    return result;
}
```

#### 2.6.4 总结

双指针类的滑动窗口问题思维复杂度并不高，但是出错点往往在细节。

记忆常用的解题模版还是很有必要的，特别是对于这种变量名多，容易混淆的题型。

有了这个框架，思考的点就转化为 “什么条件下移动左指针”，无关信息少了，思考加实现自然不是问题。

### 2.7 广度优先搜索

#### 2.7.1 简介

#### 2.7.2 解题框架

#### 2.7.3 题目实战

### 2.8 深度优先搜索

#### 2.8.1 简介

#### 2.8.2 解题框架

#### 2.8.3 题目实战
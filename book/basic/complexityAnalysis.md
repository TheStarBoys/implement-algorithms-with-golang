# 复杂度分析

## 简介

复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。 

### 为什么需要复杂度分析？

你可能会有些**疑惑**，我把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。为什么还要做时间、空间复杂度分析呢？这种分析方法能比我实实在在跑一遍得到的数据更准确吗？ 

这种方法被称作**事后统计法**，有非常大的局限性。

**1. 测试结果非常依赖测试环境**

比如，同样的代码分别在 **Intel Core i9** 处理器和 **Intel Core i3** 处理器运行，**i9** 肯定比 **i3 **快。还有，比如原本在这台机器上 a 代码执行的速度比 b 代码要快，等我们换到另一台机器上时，可能会有截然相反的结果。 

**2. 测试结果受数据规模的影响很大**

后面我们会讲排序算法，我们先拿它举个例子。对同一个排序算法，待排序数据的有序度不一样，排序的执行时间就会有很大的差别。极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作，执行时间就会非常短。除此之外，如果测试数据规模太小，测试结果可能无法真实地反应算法的性能。比如，对于小规模的数据排序，插入排序可能反倒会比快速排序要快！所以，我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。这就是我们今天要讲的时间、空间复杂度分析方法。 

## 大 O 复杂度表示法

如何估算算法执行效率？以这段代码为例：

```go
func sum(n int) int {
    sum := 0
    for i := 1; i <= n; i++ {
        sum += i
    }
    
    return sum
}
```

假设每行代码执行时间一样，为 `unit_time`，第2行 `sum := 0` 需要一个 `unit_time`，第3行和第4行都运行了 n 遍，所以需要 `2n * unit_time `。所以这段代码总的执行时间为 `T(n) = (2n+1) * unit_time`，**可以看出所有代码的执行时间 T(n) 与每行代码的执行次数成正比**。



同样的思路，来分析这段代码：

```go
func cal(n int) int {
    sum := 0
    for i := 1; i <= n; i++ {
        for j := 1; j <= n; j++ {
            sum += i * j
        }
    }
    
    return sum
}
```

第2行代码需要一个 `unit_time`，第3行代码循环执行了 n 遍，需要 `n * unit_time` 的执行时间。第4行和第5行代码循环执行了 n^2 遍，所以需要 `2(n^2) * unit_time` 的执行时间。所以总的执行时间为 `T(n) = (2n^2 + n + 1) * unit_time`。

尽管我们不知道 `unit_time` 的具体值，但是通过这两段代码执行时间的推导过程，我们可以得到一个非常重要的规律，那就是，**所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比**。 

我们可以把这个规律总结成一个公式。注意，大 O 就要登场了！ 



![img](https://static001.geekbang.org/resource/image/22/ef/22900968aa2b190072c985a08b0e92ef.png) 

具体解释一下这个公式。其中，T(n) 我们已经讲过了，它表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。 

所以，第一个例子中的 `T(n) = (2n+1) * unit_time`，第二个例子中的 `T(n) = (2n^2 + n + 1) * unit_time`。这就是**大 O 时间复杂度表示法**。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示**代码执行时间随数据规模增长的变化趋势**，所以，也叫作**渐进时间复杂度**（asymptotic time complexity），简称**时间复杂度**。 

### 复杂度量级

 ![img](https://static001.geekbang.org/resource/image/37/0a/3723793cc5c810e9d5b06bc95325bf0a.jpg) 

对于刚罗列的复杂度量级，我们可以粗略地分为两类，**多项式量级**和**非多项式量级**。其中，非多项式量级只有两个：O(2n) 和 O(n!)。

我们把时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。

当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。因此，关于 NP 时间复杂度我就不展开讲了。我们主要来看几种常见的**多项式时间复杂度**。 

### 常见的多项式时间复杂度

**1. O(1)**

**2. O(logn)、O(nlogn)**

**3. O(m + n)、O(m * n)**

## 总结

## 引用

> [数据结构与算法之美](https://time.geekbang.org/column/intro/126)
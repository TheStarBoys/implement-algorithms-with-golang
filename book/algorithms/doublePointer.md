# 双指针

## 简介

> 引用自：[LeetCode](https://leetcode-cn.com/explore/learn/card/array-and-string/201/two-pointer-technique/782/)

所谓双指针，并不一定是一个指针。什么意思呢？在数组问题中，双指针就是两个数组的下标；在链表中，双指针才是真正的指针，指向了两个不同的结点。



## 情景一

使用双指针技巧的典型场景之一是你想要

> 从两端向中间迭代数组。

这时你可以使用双指针技巧：

> 一个指针从始端开始，而另一个指针从末端开始。

值得注意的是，这种技巧经常在`排序`数组中使用。

### 反转数组中的元素

#### 题目描述

给定一个数组，将数组中所有元素反转。 不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。 

**示例1：**

```
输入：[1,2,3,4]
输出：[4,3,2,1]
```

#### 题目分析

其思想是将第一个元素与末尾进行交换，再向前移动到下一个元素，并不断地交换，直到它到达中间位置。

我们可以同时使用两个指针来完成迭代：一个`从第一个元素开始`，另一个`从最后一个元素开始`。持续交换它们所指向的元素，直到这两个指针相遇。

#### 代码实现

```go
func reverse(nums []int) {
    l, r := 0, len(nums) - 1
    for l < r {
        nums[l], nums[r] = nums[r], nums[l]
        l++
        r--
    }
}
```



### 验证回文串

#### 题目描述

给定一个字符串，验证它是否是回文串。回文串就是不管从左往右念，还是从右往左念，都是一样的读法的字符串。

**示例 1:**

```
输入: "aba"
输出: true
```

**示例 2:**

```
输入: "abca"
输出: false
```

#### 题目分析

通过观察很容易发现，如果以双指针指向字符串的首尾，每次迭代，双指针都向中间靠拢，直到双指针发生碰撞。此过程中，如果该字符串是回文串，那么左指针和右指针所指向的字符应该相等。

#### 代码实现

```go
func isPalindrome(s string) bool {
    l, r := 0, len(s) - 1
    for l < r {
        if s[l] != s[r] {
            return false
        }
        l++
        r--
    }
    
    return true
}
```



### 两数之和

#### 题目描述

给定一个已按照**升序排列**的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2*。*

**说明:**

- 返回的下标值（index1 和 index2）**不是从零开始**的。
- 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

**示例:**

```
输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```

#### 代码实现

```go
func twoSum(numbers []int, target int) []int {
    l, r := 0, len(numbers) - 1
    for l < r {
        sum := numbers[l] + numbers[r]
        if sum < target {
            l++
        } else if sum > target {
            r--
        } else {
            return []int{l+1, r+1}
        }
    }
    
    return []int{}
}
```



## 情景二

有时，我们可以使用`两个不同步的指针`来解决问题。

 

### 示例

------

让我们从另一个经典问题开始：

> 给定一个数组和一个值，[原地](https://en.wikipedia.org/wiki/In-place_algorithm)删除该值的所有实例并返回新的长度。

如果我们没有空间复杂度上的限制，那就更容易了。我们可以初始化一个新的数组来存储答案。如果元素不等于给定的目标值，则迭代原始数组并将元素添加到新的数组中。

实际上，它相当于使用了两个指针，一个用于原始数组的迭代，另一个总是指向新数组的最后一个位置。

###  重新考虑空间限制

------

现在让我们重新考虑空间受到限制的情况。 

我们可以采用类似的策略，我们继续使用两个指针：一个仍然用于迭代，而第二个指针总是指向`下一次添加的位置`。 

以下代码可以供你参考：

```go
public int removeElement(int[] nums, int val) {
    int k = 0;
    for (int i = 0; i < nums.length; ++i) {
        if (nums[i] != val) {
            nums[k] = nums[i];
            k++;
        }
    }
    return k;
}
```

在上面的例子中，我们使用两个指针，一个快指针 `i` 和一个慢指针 `k` 。`i` 每次移动一步，而 `k` 只在添加新的被需要的值时才移动一步。

 

### 总结

------

这是你需要使用双指针技巧的一种非常常见的情况：

> 同时有一个慢指针和一个快指针。

解决这类问题的关键是

> 确定两个指针的移动策略。

与前一个场景类似，你有时可能需要在使用双指针技巧之前对数组进行排序，也可能需要运用贪心想法来决定你的运动策略。

## 情景二案例

### 移除数组元素

#### 题目描述

给你一个数组 *nums* 和一个值 *val*，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 *val* 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

 

**示例 1:**

```
给定 nums = [3,2,2,3], val = 3,

函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。

你不需要考虑数组中超出新长度后面的元素。
```

**示例 2:**

```
给定 nums = [0,1,2,2,3,0,4,2], val = 2,

函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

注意这五个元素可为任意顺序。

你不需要考虑数组中超出新长度后面的元素。
```

 

**说明:**

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

#### 代码实现

```go
func removeElement(nums []int, val int) int {
    if len(nums) == 0 {
        return 0
    }
    cur := 0
    for i := 0; i < len(nums); i++ {
        if nums[i] != val {
            nums[cur] = nums[i]
            cur++
        }
    }
    return cur
}
```

